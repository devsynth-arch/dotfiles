#!/usr/bin/env python3
import gi
import os
import re
import subprocess
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GdkPixbuf, GLib, Gdk

from rice_editor_config import RiceEditorConfig

class RiceEditorApp(Gtk.Window):
    def __init__(self):
        Gtk.Window.__init__(self, title="Rice Editor")
        self.set_position(Gtk.WindowPosition.CENTER)
        self.config = RiceEditorConfig(RiceEditorConfig("").get_current_theme())
        self.set_title(f"Rice Editor: {self.config.theme}")

        # Main container
        main_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        main_box.set_margin_start(10)
        main_box.set_margin_end(20)
        main_box.set_margin_top(20)
        main_box.set_margin_bottom(20)
        self.add(main_box)

        # Sidebar menu
        sidebar = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        sidebar.set_border_width(10)
        sidebar.set_size_request(200, -1)  # Fixed width for sidebar

        # Load SVG logo
        logo_path = os.path.expanduser('~/.config/bspwm/config/assets/profile.png')
        try:
            logo_pixbuf = GdkPixbuf.Pixbuf.new_from_file_at_scale(logo_path, 130, 130, True)
            logo_image = Gtk.Image.new_from_pixbuf(logo_pixbuf)
            sidebar.pack_start(logo_image, False, False, 10)
        except GLib.Error as e:
            print(f"Error loading logo: {e}")

        # Theme Selector
        theme_selector_label = Gtk.Label(label="Select Theme")
        sidebar.pack_start(theme_selector_label, False, False, 0)

        self.theme_selector_combo = Gtk.ComboBoxText()
        themes = [d for d in os.listdir(os.path.expanduser('~/.config/bspwm/rices/')) if os.path.isdir(os.path.expanduser(f'~/.config/bspwm/rices/{d}'))]
        for theme in sorted(themes):
            self.theme_selector_combo.append_text(theme)
        self.theme_selector_combo.set_active_id(self.config.theme)
        self.theme_selector_combo.connect("changed", self.on_theme_selected)
        sidebar.pack_start(self.theme_selector_combo, False, False, 0)

        # Menu buttons container
        menu_options = [
            "Rice Options",
            "General Options",
            "Help"
        ]

        for option in menu_options:
            button = Gtk.Button(label=option)
            button.set_name(option.lower().replace(" ", "_"))
            sidebar.pack_start(button, False, False, 0)

        # Main content area
        self.content_stack = Gtk.Stack()
        self.content_stack.set_transition_type(Gtk.StackTransitionType.SLIDE_LEFT_RIGHT)

        # Header
        header = Gtk.Label()
        header.set_markup(f"<big><b>Rice Editor : </b> <span foreground='yellow'>{self.config.theme}</span></big>")
        header.set_margin_top(20)
        header.set_margin_bottom(20)

        # Content for each option
        rice_options_content = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        notebook = Gtk.Notebook()
        tabs = ["Bspwm", "Picom", "Terminal", "Misc"]

        for tab_name in tabs:
            label = Gtk.Label(label=tab_name)
            content = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
            content.set_border_width(10)

            if tab_name == "Bspwm":
                # Border Width Configuration
                border_width_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
                border_width_label = Gtk.Label()
                border_width_label.set_markup("Border Width <i><small>(0-9)</small></i>")
                border_width_label.set_halign(Gtk.Align.START)

                self.border_width_entry = Gtk.Entry()
                self.border_width_entry.set_width_chars(5)
                self.border_width_entry.set_max_length(1)
                self.border_width_entry.set_input_purpose(Gtk.InputPurpose.DIGITS)

                # Set initial value
                initial_border_width = self.config.get_border_width()
                self.border_width_entry.set_text(str(initial_border_width))

                # Validation for numeric input
                self.border_width_entry.connect("insert-text", self.on_border_entry_insert)

                border_width_apply_button = Gtk.Button(label="Apply")
                border_width_apply_button.connect("clicked", self.on_apply_border_width)

                border_width_box.pack_start(border_width_label, True, True, 0)
                border_width_box.pack_end(border_width_apply_button, False, False, 0)
                border_width_box.pack_end(self.border_width_entry, False, False, 0)

                content.pack_start(border_width_box, False, False, 7)

                # Normal Border Color Configuration
                normal_border_color_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
                normal_border_color_label = Gtk.Label(label="Normal border color")
                normal_border_color_label.set_halign(Gtk.Align.START)

                # Color Picker Button
                color_picker_button = Gtk.ColorButton()
                color_picker_button.set_title("Select Normal Border Color")

                self.normal_border_color_entry = Gtk.Entry()
                self.normal_border_color_entry.set_width_chars(8)
                self.normal_border_color_entry.set_max_length(7)

                # Set initial value
                initial_normal_border_color = self.config.get_border_color('NORMAL_BC')
                self.normal_border_color_entry.set_text(initial_normal_border_color)
                normal_initial_color = Gdk.RGBA()
                normal_initial_color.parse(initial_normal_border_color)
                color_picker_button.set_rgba(normal_initial_color)

                # Connect color picker to entry
                color_picker_button.connect("color-set", self.on_color_picked, self.normal_border_color_entry)

                # Validation for hex color
                self.normal_border_color_entry.connect("insert-text", self.on_color_entry_insert)

                normal_border_color_apply_button = Gtk.Button(label="Apply")
                normal_border_color_apply_button.connect("clicked", self.on_apply_normal_border_color)

                normal_border_color_box.pack_start(normal_border_color_label, True, True, 0)
                normal_border_color_box.pack_end(normal_border_color_apply_button, False, False, 0)
                normal_border_color_box.pack_end(self.normal_border_color_entry, False, False, 0)
                normal_border_color_box.pack_end(color_picker_button, False, False, 0)

                content.pack_start(normal_border_color_box, False, False, 7)

                # Focused Border Color Configuration
                focused_border_color_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
                focused_border_color_label = Gtk.Label(label="Focused border color")
                focused_border_color_label.set_halign(Gtk.Align.START)

                # Color Picker Button
                focused_color_picker_button = Gtk.ColorButton()
                focused_color_picker_button.set_title("Select Focused Border Color")

                self.focused_border_color_entry = Gtk.Entry()
                self.focused_border_color_entry.set_width_chars(8)
                self.focused_border_color_entry.set_max_length(7)

                # Set initial value
                initial_focused_border_color = self.config.get_border_color('FOCUSED_BC')
                self.focused_border_color_entry.set_text(initial_focused_border_color)
                focused_initial_color = Gdk.RGBA()
                focused_initial_color.parse(initial_focused_border_color)
                focused_color_picker_button.set_rgba(focused_initial_color)

                # Connect color picker to entry
                focused_color_picker_button.connect("color-set", self.on_color_picked, self.focused_border_color_entry)

                # Validation for hex color
                self.focused_border_color_entry.connect("insert-text", self.on_color_entry_insert)

                focused_border_color_apply_button = Gtk.Button(label="Apply")
                focused_border_color_apply_button.connect("clicked", self.on_apply_focused_border_color)

                focused_border_color_box.pack_start(focused_border_color_label, True, True, 0)
                focused_border_color_box.pack_end(focused_border_color_apply_button, False, False, 0)
                focused_border_color_box.pack_end(self.focused_border_color_entry, False, False, 0)
                focused_border_color_box.pack_end(focused_color_picker_button, False, False, 0)

                content.pack_start(focused_border_color_box, False, False, 7)

            # Inside the __init__ method, in the notebook section, where the Picom tab is
            elif tab_name == "Picom":
                # Corner Radius Configuration
                corner_radius_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
                corner_radius_label = Gtk.Label()
                corner_radius_label.set_markup("Corner Radius <i><small>(0-99)</small></i>")
                corner_radius_label.set_halign(Gtk.Align.START)

                self.corner_radius_entry = Gtk.Entry()
                self.corner_radius_entry.set_width_chars(5)
                self.corner_radius_entry.set_max_length(2)
                self.corner_radius_entry.set_input_purpose(Gtk.InputPurpose.DIGITS)

                # Set initial value
                initial_corner_radius = self.config.get_corner_radius()
                self.corner_radius_entry.set_text(str(initial_corner_radius))

                # Validation for numeric input
                self.corner_radius_entry.connect("insert-text", self.on_corner_radius_entry_insert)

                corner_radius_apply_button = Gtk.Button(label="Apply")
                corner_radius_apply_button.connect("clicked", self.on_apply_corner_radius)

                corner_radius_box.pack_start(corner_radius_label, True, True, 0)
                corner_radius_box.pack_end(corner_radius_apply_button, False, False, 0)
                corner_radius_box.pack_end(self.corner_radius_entry, False, False, 0)

                content.pack_start(corner_radius_box, False, False, 7)

                # Shadows Configuration
                shadows_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
                shadows_label = Gtk.Label(label="Shadows")
                shadows_label.set_halign(Gtk.Align.START)

                self.shadows_switch = Gtk.Switch()

                # Set initial value
                initial_shadows_state = self.config.get_shadows_state()
                self.shadows_switch.set_active(initial_shadows_state)

                # Connect switch to handler
                self.shadows_switch.connect("state-set", self.on_shadows_switch_toggled)

                shadows_box.pack_start(shadows_label, True, True, 0)
                shadows_box.pack_end(self.shadows_switch, False, False, 0)

                content.pack_start(shadows_box, False, False, 7)

                # Shadow Color Configuration
                shadow_color_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
                shadow_color_label = Gtk.Label(label="Shadow Color")
                shadow_color_label.set_halign(Gtk.Align.START)

                # Color Picker Button
                shadow_color_picker_button = Gtk.ColorButton()
                shadow_color_picker_button.set_title("Select Shadow Color")

                self.shadow_color_entry = Gtk.Entry()
                self.shadow_color_entry.set_width_chars(8)
                self.shadow_color_entry.set_max_length(7)

                # Set initial value
                initial_shadow_color = self.config.get_shadow_color()
                self.shadow_color_entry.set_text(initial_shadow_color)
                shadow_initial_color = Gdk.RGBA()
                shadow_initial_color.parse(initial_shadow_color)
                shadow_color_picker_button.set_rgba(shadow_initial_color)

                # Connect color picker to entry
                shadow_color_picker_button.connect("color-set", self.on_color_picked, self.shadow_color_entry)

                # Validation for hex color
                self.shadow_color_entry.connect("insert-text", self.on_color_entry_insert)

                shadow_color_apply_button = Gtk.Button(label="Apply")
                shadow_color_apply_button.connect("clicked", self.on_apply_shadow_color)

                shadow_color_box.pack_start(shadow_color_label, True, True, 0)
                shadow_color_box.pack_end(shadow_color_apply_button, False, False, 0)
                shadow_color_box.pack_end(self.shadow_color_entry, False, False, 0)
                shadow_color_box.pack_end(shadow_color_picker_button, False, False, 0)

                content.pack_start(shadow_color_box, False, False, 7)

                # Fading Effect Configuration
                fading_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
                fading_label = Gtk.Label(label="Fading Effect")
                fading_label.set_halign(Gtk.Align.START)

                self.fading_switch = Gtk.Switch()

                # Set initial value
                initial_fading_state = self.config.get_fading_state()
                self.fading_switch.set_active(initial_fading_state)

                # Connect switch to handler
                self.fading_switch.connect("state-set", self.on_fading_switch_toggled)

                fading_box.pack_start(fading_label, True, True, 0)
                fading_box.pack_end(self.fading_switch, False, False, 0)

                content.pack_start(fading_box, False, False, 7)

                # Blur Effect Configuration
                blur_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
                blur_label = Gtk.Label(label="Blur Effect")
                blur_label.set_halign(Gtk.Align.START)

                self.blur_switch = Gtk.Switch()

                # Set initial value
                initial_blur_state = self.config.get_blur_state()
                self.blur_switch.set_active(initial_blur_state)

                # Connect switch to handler
                self.blur_switch.connect("state-set", self.on_blur_switch_toggled)

                blur_box.pack_start(blur_label, True, True, 0)
                blur_box.pack_end(self.blur_switch, False, False, 0)

                content.pack_start(blur_box, False, False, 7)

                # Animations Configuration
                animations_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
                animations_label = Gtk.Label(label="Animations")
                animations_label.set_halign(Gtk.Align.START)

                self.animations_switch = Gtk.Switch()

                # Set initial value
                initial_animations_state = self.config.get_animations_state()
                self.animations_switch.set_active(initial_animations_state)

                # Connect switch to handler
                self.animations_switch.connect("state-set", self.on_animations_switch_toggled)

                animations_box.pack_start(animations_label, True, True, 0)
                animations_box.pack_end(self.animations_switch, False, False, 0)

                content.pack_start(animations_box, False, False, 7)

            elif tab_name == "Terminal":
                # Header Transparency
                transparency_label = Gtk.Label()
                transparency_label.set_markup("<small>The blur effect only affects terminals with transparency. 1.0 means\nno transparency</small>")
                transparency_label.set_halign(Gtk.Align.START)

                content.pack_start(transparency_label, False, False, 7)

                # Terminal Transparency Configuration
                term_opacity_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
                term_opacity_label = Gtk.Label()
                term_opacity_label.set_markup("Terminal Transparency <i><small>(Range 0.1 - 1.0)</small></i>")
                term_opacity_label.set_halign(Gtk.Align.START)

                self.term_opacity_entry = Gtk.Entry()
                self.term_opacity_entry.set_width_chars(5)
                self.term_opacity_entry.set_max_length(4)

                # Set initial value
                initial_term_opacity = self.config.get_terminal_opacity()
                self.term_opacity_entry.set_text(str(initial_term_opacity))

                # Validation for numeric input
                self.term_opacity_entry.connect("insert-text", self.on_terminal_opacity_insert)

                term_opacity_apply_button = Gtk.Button(label="Apply")
                term_opacity_apply_button.connect("clicked", self.on_apply_terminal_opacity)

                term_opacity_box.pack_start(term_opacity_label, True, True, 0)
                term_opacity_box.pack_end(term_opacity_apply_button, False, False, 0)
                term_opacity_box.pack_end(self.term_opacity_entry, False, False, 0)

                content.pack_start(term_opacity_box, False, False, 10)

                # Header Alacritty
                alacritty_label = Gtk.Label()
                alacritty_label.set_markup("<small>The following 2 options will change the appearance for both terminals,\nAlacritty and Kitty</small>")
                alacritty_label.set_halign(Gtk.Align.START)

                content.pack_start(alacritty_label, False, False, 7)

                # Font Size Configuration
                font_size_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
                font_size_label = Gtk.Label(label="Font Size")
                font_size_label.set_halign(Gtk.Align.START)

                self.font_size_entry = Gtk.Entry()
                self.font_size_entry.set_width_chars(5)
                self.font_size_entry.set_max_length(2)
                self.font_size_entry.set_input_purpose(Gtk.InputPurpose.DIGITS)

                # Set initial value
                initial_font_size = self.config.get_font_size()
                self.font_size_entry.set_text(str(initial_font_size))

                # Validation for numeric input
                self.font_size_entry.connect("insert-text", self.on_font_size_insert)

                font_size_apply_button = Gtk.Button(label="Apply")
                font_size_apply_button.connect("clicked", self.on_apply_font_size)

                font_size_box.pack_start(font_size_label, True, True, 0)
                font_size_box.pack_end(font_size_apply_button, False, False, 0)
                font_size_box.pack_end(self.font_size_entry, False, False, 0)

                content.pack_start(font_size_box, False, False, 7)

                # Font Name Configuration
                font_name_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
                font_name_label = Gtk.Label(label="Font Name")
                font_name_label.set_halign(Gtk.Align.START)

                # Button to open font chooser dialog
                font_chooser_button = Gtk.Button(label="Select")
                font_chooser_button.connect("clicked", self.on_font_chooser_clicked)

                # Entry for manual font name input
                self.font_name_entry = Gtk.Entry()
                self.font_name_entry.set_width_chars(20)

                # Set initial value
                initial_font_name = self.config.get_font_name()
                self.font_name_entry.set_text(initial_font_name)

                # Apply button
                font_name_apply_button = Gtk.Button(label="Apply")
                font_name_apply_button.connect("clicked", self.on_apply_font_name)

                font_name_box.pack_start(font_name_label, True, True, 0)
                font_name_box.pack_end(font_name_apply_button, False, False, 0)
                font_name_box.pack_end(self.font_name_entry, False, False, 0)
                font_name_box.pack_end(font_chooser_button, False, False, 0)

                content.pack_start(font_name_box, False, False, 7)

            elif tab_name == "Misc":
                # Wall Engine Configuration
                wall_engine_label = Gtk.Label(label="Wall Engine")
                wall_engine_label.set_halign(Gtk.Align.START)

                # Dropdown for Wall Engine options
                self.wall_engine_combo = Gtk.ComboBoxText()
                self.wall_engine_combo.append("Theme", "Default")
                self.wall_engine_combo.append("CustomDir", "Custom Dir")
                self.wall_engine_combo.append("CustomImage", "Custom Image")
                self.wall_engine_combo.append("CustomAnimated", "Custom Animated")
                self.wall_engine_combo.append("Slideshow", "SlideShow")

                # Set initial value
                initial_engine = self.config.get_wall_engine()
                self.wall_engine_combo.set_active_id(initial_engine)
                self.wall_engine_combo.connect("changed", self.on_wall_engine_changed)

                # Container for dynamic options
                self.wall_engine_options_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)

                # Pack components
                content.pack_start(wall_engine_label, False, False, 7)
                content.pack_start(self.wall_engine_combo, False, False, 10)
                content.pack_start(self.wall_engine_options_box, False, False, 7)

                # Initial display based on current value
                self.update_wall_engine_options(initial_engine)

            else:
                # A temporary label to show the content of each tab
                placeholder = Gtk.Label(label=f"Configurations for {tab_name}")
                content.pack_start(placeholder, True, True, 0)

            notebook.append_page(content, label)

        rice_options_content.pack_start(notebook, True, True, 0)

        # Content for General Options
        general_frame = Gtk.Frame()  # Create a Gtk.Frame
        general_frame.set_shadow_type(Gtk.ShadowType.IN)  # Configure the border shadow type

        general_options_content = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        general_label = Gtk.Label(label="These options will affect all themes and the environment.")
        general_label.set_margin_bottom(10)
        general_label.set_margin_top(10)
        general_options_content.pack_start(general_label, False, False, 0)

        # Picom Backend Configuration
        picom_backend_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
        picom_backend_label = Gtk.Label(label="Picom Backend")
        picom_backend_label.set_halign(Gtk.Align.START)

        # ComboBox for backend options
        self.picom_backend_combo = Gtk.ComboBoxText()
        self.picom_backend_combo.append("xrender", "xrender")
        self.picom_backend_combo.append("glx", "glx")
        self.picom_backend_combo.append("egl", "egl")

        # Set initial value
        initial_backend = self.config.get_picom_backend()
        self.picom_backend_combo.set_active_id(initial_backend)

        # Connect change event
        self.picom_backend_combo.connect("changed", self.on_apply_picom_backend)

        picom_backend_box.pack_start(picom_backend_label, True, True, 10)
        picom_backend_box.pack_end(self.picom_backend_combo, False, False, 10)

        general_options_content.pack_start(picom_backend_box, False, False, 7)

        # vSync Configuration
        vsync_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
        vsync_label = Gtk.Label(label="vSync")
        vsync_label.set_halign(Gtk.Align.START)

        self.vsync_switch = Gtk.Switch()

        # Set initial value
        initial_vsync_state = self.config.get_vsync_state()
        self.vsync_switch.set_active(initial_vsync_state)

        # Connect change event
        self.vsync_switch.connect("state-set", self.on_vsync_switch_toggled)

        vsync_box.pack_start(vsync_label, True, True, 10)
        vsync_box.pack_end(self.vsync_switch, False, False, 10)

        general_options_content.pack_start(vsync_box, False, False, 7)

        # Bspwm Window Gap Configuration
        window_gap_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
        window_gap_label = Gtk.Label(label="Bspwm Window Gap")
        window_gap_label.set_halign(Gtk.Align.START)

        self.window_gap_entry = Gtk.Entry()
        self.window_gap_entry.set_width_chars(5)
        self.window_gap_entry.set_max_length(2)
        self.window_gap_entry.set_input_purpose(Gtk.InputPurpose.DIGITS)

        # Set initial value
        initial_window_gap = self.config.get_window_gap()
        self.window_gap_entry.set_text(str(initial_window_gap))

        # Validation to allow only numbers between 0 and 20
        self.window_gap_entry.connect("insert-text", self.on_window_gap_entry_insert)

        apply_button = Gtk.Button(label="Apply")
        apply_button.connect("clicked", self.on_apply_window_gap)

        window_gap_box.pack_start(window_gap_label, True, True, 10)
        window_gap_box.pack_end(apply_button, False, False, 10)
        window_gap_box.pack_end(self.window_gap_entry, False, False, 0)

        general_options_content.pack_start(window_gap_box, False, False, 7)

        general_frame.add(general_options_content)  # Add content to Gtk.Frame

        # Pixel-Art on Terminal Configuration
        pixel_art_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
        pixel_art_label = Gtk.Label(label="Pixel-Art on Terminal")
        pixel_art_label.set_halign(Gtk.Align.START)

        self.pixel_art_switch = Gtk.Switch()

        # Set initial value
        initial_pixel_art_state = self.config.get_pixel_art_state()
        self.pixel_art_switch.set_active(initial_pixel_art_state)

        # Connect change event
        self.pixel_art_switch.connect("state-set", self.on_pixel_art_switch_toggled)

        pixel_art_box.pack_start(pixel_art_label, True, True, 10)
        pixel_art_box.pack_end(self.pixel_art_switch, False, False, 10)

        general_options_content.pack_start(pixel_art_box, False, False, 7)

        # fzf-tab completion Configuration
        fzf_tab_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=7)
        fzf_tab_label = Gtk.Label(label="Disable fzf-tab completion")
        fzf_tab_label.set_halign(Gtk.Align.START)

        self.fzf_tab_switch = Gtk.Switch()

        # Set initial value
        initial_fzf_tab_state = self.config.get_fzf_tab_state()
        self.fzf_tab_switch.set_active(initial_fzf_tab_state)

        # Connect change event
        self.fzf_tab_switch.connect("state-set", self.on_fzf_tab_switch_toggled)

        fzf_tab_box.pack_start(fzf_tab_label, True, True, 10)
        fzf_tab_box.pack_end(self.fzf_tab_switch, False, False, 10)

        general_options_content.pack_start(fzf_tab_box, False, False, 7)

        # Content for Help
        help_frame = Gtk.Frame()  # Create a Gtk.Frame
        help_frame.set_shadow_type(Gtk.ShadowType.IN)  # Configure the border shadow type

        help_content = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        help_label = Gtk.Label(label="If you open RiceEditor in a theme, and switch to another\ntheme, you will continue editing the theme you were in before.\nYou need to close RiceEditor and open it again.\nThe name of the theme you are editing is in yellow letters.\nBe careful!!")
        help_content.pack_start(help_label, True, True, 10)

        help_frame.add(help_content)  # Add content to Gtk.Frame

        # Add content to stack
        self.content_stack.add_named(rice_options_content, "rice_options")
        self.content_stack.add_named(general_frame, "general_options")
        self.content_stack.add_named(help_frame, "help")

        # Main content container
        content_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        content_box.pack_start(header, False, False, 0)
        content_box.pack_start(self.content_stack, True, True, 0)

        # Add sidebar menu and content area to main container
        main_box.pack_start(sidebar, False, False, 0)
        main_box.pack_start(content_box, True, True, 0)

        # Connect menu buttons
        sidebar.get_children()[1].connect("clicked", self.on_menu_clicked, "rice_options")
        sidebar.get_children()[2].connect("clicked", self.on_menu_clicked, "general_options")
        sidebar.get_children()[3].connect("clicked", self.on_menu_clicked, "help")

        # Signal connection
        self.connect("destroy", Gtk.main_quit)

    def show_error_dialog(self, message):
        dialog = Gtk.MessageDialog(
            parent=self,
            flags=Gtk.DialogFlags.MODAL,
            type=Gtk.MessageType.ERROR,
            buttons=Gtk.ButtonsType.OK,
            message_format=message
        )
        dialog.run()
        dialog.destroy()

    def on_menu_clicked(self, button, page_name):
        self.content_stack.set_visible_child_name(page_name)

    def on_border_entry_insert(self, entry, new_text, new_text_length, position):
        if not new_text.isdigit():
            entry.stop_emission_by_name("insert-text")

    def on_color_entry_insert(self, entry, new_text, new_text_length, position):
        valid_chars = set('0123456789ABCDEFabcdef#')
        for char in new_text:
            if char not in valid_chars:
                entry.stop_emission_by_name("insert-text")
                return

    def on_color_picked(self, color_button, entry):
        color = color_button.get_rgba()
        hex_color = '#{:02x}{:02x}{:02x}'.format(
            int(color.red * 255),
            int(color.green * 255),
            int(color.blue * 255)
        )
        entry.set_text(hex_color.upper())

    def on_apply_border_width(self, button):
        new_border_width = self.border_width_entry.get_text()
        try:
            width = int(new_border_width)
            if 0 <= width <= 9:
                self.config.set_border_width(width)
            else:
                self.show_error_dialog("Border width value out of range (0-9)")
        except ValueError:
            self.show_error_dialog("Invalid border width value")

    def on_apply_normal_border_color(self, button):
        new_color = self.normal_border_color_entry.get_text()
        if re.match(r'^#[0-9A-Fa-f]{6}$', new_color):
            self.config.set_border_color('NORMAL_BC', 'border_normal_color', new_color)
        else:
            self.show_error_dialog("Invalid color format")

    def on_apply_focused_border_color(self, button):
        new_color = self.focused_border_color_entry.get_text()
        if re.match(r'^#[0-9A-Fa-f]{6}$', new_color):
            self.config.set_border_color('FOCUSED_BC', 'border_focused_color', new_color)
        else:
            self.show_error_dialog("Invalid color format")

    def on_corner_radius_entry_insert(self, entry, new_text, new_text_length, position):
        if not new_text.isdigit():
            entry.stop_emission_by_name("insert-text")

    def on_apply_corner_radius(self, button):
        new_corner_radius = self.corner_radius_entry.get_text()
        try:
            radius = int(new_corner_radius)
            if 0 <= radius <= 99:
                self.config.set_corner_radius(radius)
            else:
                self.show_error_dialog("Corner radius value out of range (0-99)")
        except ValueError:
            self.show_error_dialog("Invalid corner radius value")

    def on_shadows_switch_toggled(self, switch, state):
        self.config.set_shadows_state(state)
        return False

    def on_apply_shadow_color(self, button):
        new_color = self.shadow_color_entry.get_text()
        if re.match(r'^#[0-9A-Fa-f]{6}$', new_color):
            self.config.set_shadow_color(new_color)
        else:
            self.show_error_dialog("Invalid color format")

    def on_fading_switch_toggled(self, switch, state):
        self.config.set_fading_state(state)
        return False

    def on_blur_switch_toggled(self, switch, state):
        self.config.set_blur_state(state)
        return False

    def on_animations_switch_toggled(self, switch, state):
        self.config.set_animations_state(state)
        return False

    def on_terminal_opacity_insert(self, entry, new_text, new_text_length, position):
        current_text = entry.get_text() + new_text
        if not re.match(r'^([0-9]{0,1}(\.[0-9]{0,2})?|1(\.0{0,2})?)$', current_text):
            entry.stop_emission_by_name("insert-text")

    def on_apply_terminal_opacity(self, button):
        new_opacity = self.term_opacity_entry.get_text()
        try:
            opacity = float(new_opacity)
            if 0.1 <= opacity <= 1.0:
                self.config.set_terminal_opacity(opacity)
            else:
                self.show_error_dialog("Terminal opacity value out of range (0.1 - 1.0)")
        except ValueError:
            self.show_error_dialog("Invalid terminal opacity value")

    def on_font_size_insert(self, entry, new_text, new_text_length, position):
        if not new_text.isdigit() or len(entry.get_text() + new_text) > 2:
            entry.stop_emission_by_name("insert-text")

    def on_apply_font_size(self, button):
        new_font_size = self.font_size_entry.get_text()
        try:
            font_size = int(new_font_size)
            if 1 <= font_size <= 99:
                self.config.set_font_size(font_size)
            else:
                self.show_error_dialog("Font size value out of range (1-99)")
        except ValueError:
            self.show_error_dialog("Invalid font size value")

    def on_font_chooser_clicked(self, button):
        dialog = Gtk.FontChooserDialog(title="Select Font", parent=self)
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            font_name = dialog.get_font_desc().get_family()
            self.font_name_entry.set_text(font_name)
        dialog.destroy()

    def on_apply_font_name(self, button):
        new_font_name = self.font_name_entry.get_text()
        if new_font_name:
            self.config.set_font_name(new_font_name)
        else:
            self.show_error_dialog("Font name cannot be empty.")

    def update_wall_engine_options(self, engine):
        for child in self.wall_engine_options_box.get_children():
            self.wall_engine_options_box.remove(child)

        if engine == "Theme":  # Default
            current_theme = self.config.theme
            default_label = Gtk.Label(
                label=(
                    "Default option, it will put a random wallpaper from the\n"
                    "Walls directory of the current theme, drop your images in\n"
                    f"~/.config/bspwm/rices/{current_theme}/Walls"
                )
            )
            default_label.set_halign(Gtk.Align.START)
            default_label.set_justify(Gtk.Justification.LEFT)  # Align multi-line to the left

            apply_button = Gtk.Button(label="Apply")
            apply_button.connect("clicked", self.on_apply_wall_engine, "Theme")

            self.wall_engine_options_box.pack_start(default_label, False, False, 10)
            self.wall_engine_options_box.pack_start(apply_button, False, False, 10)

        elif engine == "CustomDir":  # Custom Directory
            # Label for Custom Dir
            custom_dir_label = Gtk.Label(
                label="Select the directory from where you want to load the random\nimages"
            )
            custom_dir_label.set_halign(Gtk.Align.START)
            custom_dir_label.set_justify(Gtk.Justification.LEFT)

            # Entry and Buttons
            custom_dir_entry = Gtk.Entry()
            custom_dir_entry.set_text(self.config.get_custom_dir())

            browse_button = Gtk.Button(label="Browse")
            browse_button.connect("clicked", self.on_browse_directory, custom_dir_entry)

            apply_button = Gtk.Button(label="Apply")
            apply_button.connect("clicked", self.on_apply_wall_engine, "CustomDir", custom_dir_entry)

            # Layout
            hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            hbox.pack_start(custom_dir_entry, True, True, 0)
            hbox.pack_end(browse_button, False, False, 0)
            hbox.pack_end(apply_button, False, False, 0)

            self.wall_engine_options_box.pack_start(custom_dir_label, False, False, 10)
            self.wall_engine_options_box.pack_start(hbox, False, False, 10)

        elif engine == "CustomImage":  # Custom Image
            # Label for Custom Image
            custom_image_label = Gtk.Label(
                label="Select the image you want to use as wallpaper."
            )
            custom_image_label.set_halign(Gtk.Align.START)
            custom_image_label.set_justify(Gtk.Justification.LEFT)

            # Entry and Buttons
            custom_image_entry = Gtk.Entry()
            custom_image_entry.set_text(self.config.get_custom_wall())

            browse_button = Gtk.Button(label="Browse")
            browse_button.connect("clicked", self.on_browse_file, custom_image_entry)

            apply_button = Gtk.Button(label="Apply")
            apply_button.connect("clicked", self.on_apply_wall_engine, "CustomImage", custom_image_entry)

            # Layout
            hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            hbox.pack_start(custom_image_entry, True, True, 0)
            hbox.pack_end(browse_button, False, False, 0)
            hbox.pack_end(apply_button, False, False, 0)

            self.wall_engine_options_box.pack_start(custom_image_label, False, False, 10)
            self.wall_engine_options_box.pack_start(hbox, False, False, 10)

        elif engine == "CustomAnimated":  # Custom Image
            # Label for Custom Animated
            custom_animated_label = Gtk.Label(
                label="Select the file you want to use as wallpaper.\nValid files (mp4, mkv, gif)"
            )
            custom_animated_label.set_halign(Gtk.Align.START)
            custom_animated_label.set_justify(Gtk.Justification.LEFT)

            # Entry and Buttons
            custom_animated_entry = Gtk.Entry()
            custom_animated_entry.set_text(self.config.get_custom_animated())

            browse_button = Gtk.Button(label="Browse")
            browse_button.connect("clicked", self.on_browse_animated, custom_animated_entry)

            apply_button = Gtk.Button(label="Apply")
            apply_button.connect("clicked", self.on_apply_wall_engine, "CustomAnimated", custom_animated_entry)

            # Layout
            hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            hbox.pack_start(custom_animated_entry, True, True, 0)
            hbox.pack_end(browse_button, False, False, 0)
            hbox.pack_end(apply_button, False, False, 0)

            self.wall_engine_options_box.pack_start(custom_animated_label, False, False, 10)
            self.wall_engine_options_box.pack_start(hbox, False, False, 10)

        elif engine == "Slideshow":  # Slideshow 15 minutes
            current_theme = self.config.theme
            slideshow_label = Gtk.Label(
                label=(
                    "Change your wallpaper randomly every 15 minutes.\n"
                    "From walls directory of the current theme, drop your images in\n"
                    f"~/.config/bspwm/rices/{current_theme}/Walls"
                )
            )
            slideshow_label.set_halign(Gtk.Align.START)
            slideshow_label.set_justify(Gtk.Justification.LEFT)  # Align multi-line to the left

            apply_button = Gtk.Button(label="Apply")
            apply_button.connect("clicked", self.on_apply_wall_engine, "Slideshow")

            self.wall_engine_options_box.pack_start(slideshow_label, False, False, 10)
            self.wall_engine_options_box.pack_start(apply_button, False, False, 10)

        self.wall_engine_options_box.show_all()

    def on_wall_engine_changed(self, combo):
        engine = combo.get_active_id()
        self.update_wall_engine_options(engine)

    def on_apply_wall_engine(self, button, engine, entry=None):
        value = entry.get_text() if entry else None
        self.config.set_wall_engine(engine, value)

    def on_browse_directory(self, button, entry):
        dialog = Gtk.FileChooserDialog(
            title="Select Directory",
            parent=self,
            action=Gtk.FileChooserAction.SELECT_FOLDER,
        )
        dialog.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_OPEN, Gtk.ResponseType.OK
        )

        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            folder = dialog.get_filename()
            entry.set_text(folder)

        dialog.destroy()

    def on_browse_file(self, button, entry):
        dialog = Gtk.FileChooserDialog(
            title="Select Image File",
            parent=self,
            action=Gtk.FileChooserAction.OPEN,
        )
        dialog.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_OPEN, Gtk.ResponseType.OK
        )

        filter_images = Gtk.FileFilter()
        filter_images.set_name("Image Files")
        filter_images.add_mime_type("image/png")
        filter_images.add_mime_type("image/jpeg")
        filter_images.add_mime_type("image/jpg")
        filter_images.add_mime_type("image/webp")
        filter_images.add_pattern("*.png")
        filter_images.add_pattern("*.jpg")
        filter_images.add_pattern("*.jpeg")
        filter_images.add_pattern("*.webp")
        dialog.add_filter(filter_images)

        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            file = dialog.get_filename()
            entry.set_text(file)

        dialog.destroy()

    def on_browse_animated(self, button, entry):
        dialog = Gtk.FileChooserDialog(
            title="Select Image File",
            parent=self,
            action=Gtk.FileChooserAction.OPEN,
        )
        dialog.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_OPEN, Gtk.ResponseType.OK
        )

        filter_images = Gtk.FileFilter()
        filter_images.set_name("Animated Files")
        filter_images.add_mime_type("image/gif")
        filter_images.add_mime_type("video/mp4")
        filter_images.add_mime_type("video/mkv")
        filter_images.add_pattern("*.gif")
        filter_images.add_pattern("*.mp4")
        filter_images.add_pattern("*.mkv")
        dialog.add_filter(filter_images)

        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            file = dialog.get_filename()
            entry.set_text(file)

        dialog.destroy()

    def on_apply_picom_backend(self, combo):
        selected_backend = combo.get_active_id()
        self.config.set_picom_backend(selected_backend)

    def on_vsync_switch_toggled(self, switch, state):
        self.config.set_vsync_state(state)
        return False

    def on_window_gap_entry_insert(self, entry, new_text, new_text_length, position):
        current_text = entry.get_text()
        try:
            full_text = current_text[:position] + new_text + current_text[position:]
            if not full_text.isdigit() or len(full_text) > 2:
                entry.stop_emission_by_name("insert-text")
        except ValueError:
            entry.stop_emission_by_name("insert-text")

    def on_apply_window_gap(self, button):
        new_gap = self.window_gap_entry.get_text()
        try:
            gap_value = int(new_gap)
            if 0 <= gap_value <= 20:
                self.config.set_window_gap(gap_value)
            else:
                self.show_error_dialog("Window gap value out of range (0-20)")
        except ValueError:
            self.show_error_dialog("Invalid window gap value")

    def on_pixel_art_switch_toggled(self, switch, state):
        self.config.set_pixel_art_state(state)
        return False

    def on_fzf_tab_switch_toggled(self, switch, state):
        self.config.set_fzf_tab_state(state)
        return False

    def on_theme_selected(self, combo):
        selected_theme = combo.get_active_id()
        if selected_theme:
            self.config.theme = selected_theme
            self.set_title(f"Rice Editor: {self.config.theme}")
            # Update header
            header = self.get_children()[0].get_children()[1].get_children()[0]
            header.set_markup(f"<big><b>Rice Editor : </b> <span foreground='yellow'>{self.config.theme}</span></big>")
            # Reload all UI elements to reflect the new theme's settings
            self.reload_ui()

    def reload_ui(self):
        self.config = RiceEditorConfig(self.config.theme)
        self.set_title(f"Rice Editor: {self.config.theme}")
        header = self.get_children()[0].get_children()[1].get_children()[0]
        header.set_markup(f"<big><b>Rice Editor : </b> <span foreground='yellow'>{self.config.theme}</span></big>")

        # Update Bspwm tab elements
        self.border_width_entry.set_text(str(self.config.get_border_width()))
        self.normal_border_color_entry.set_text(self.config.get_border_color('NORMAL_BC'))
        normal_initial_color = Gdk.RGBA()
        normal_initial_color.parse(self.config.get_border_color('NORMAL_BC'))
        # Find the color picker button for normal border color and update it
        # This requires traversing the widget tree, which can be brittle.
        # A better approach would be to store references to these widgets.
        # For now, I'll skip updating the color picker button directly and focus on the entry.

        self.focused_border_color_entry.set_text(self.config.get_border_color('FOCUSED_BC'))
        focused_initial_color = Gdk.RGBA()
        focused_initial_color.parse(self.config.get_border_color('FOCUSED_BC'))
        # Similar to above, skipping direct color picker button update.

        # Update Picom tab elements
        self.corner_radius_entry.set_text(str(self.config.get_corner_radius()))
        self.shadows_switch.set_active(self.config.get_shadows_state())
        self.shadow_color_entry.set_text(self.config.get_shadow_color())
        shadow_initial_color = Gdk.RGBA()
        shadow_initial_color.parse(self.config.get_shadow_color())
        self.fading_switch.set_active(self.config.get_fading_state())
        self.blur_switch.set_active(self.config.get_blur_state())
        self.animations_switch.set_active(self.config.get_animations_state())

        # Update Terminal tab elements
        self.term_opacity_entry.set_text(str(self.config.get_terminal_opacity()))
        self.font_size_entry.set_text(str(self.config.get_font_size()))
        self.font_name_entry.set_text(self.config.get_font_name())

        # Update Misc tab elements
        self.wall_engine_combo.set_active_id(self.config.get_wall_engine())
        self.update_wall_engine_options(self.config.get_wall_engine())

        # Update General Options tab elements
        self.picom_backend_combo.set_active_id(self.config.get_picom_backend())
        self.vsync_switch.set_active(self.config.get_vsync_state())
        self.window_gap_entry.set_text(str(self.config.get_window_gap()))
        self.pixel_art_switch.set_active(self.config.get_pixel_art_state())
        self.fzf_tab_switch.set_active(self.config.get_fzf_tab_state())

        print(f"Reloading UI for theme: {self.config.theme}")

if __name__ == "__main__":
    app = RiceEditorApp()
    app.show_all()
    Gtk.main()
